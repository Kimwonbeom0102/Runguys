=== Script Merge Summary ===
Date: 2025-01-20 14:28:42
Total Files: 26
File Names:
- ClientCharacterController.cs
- PhotonCharacterControl.cs
- PhotonCustomPropertyTypes.cs
- PhotonEventCode.cs
- PhotonManager.cs
- PunAutoSyncMonoBehaviour.cs
- GameTimerUI.cs
- LobbyGameManager.cs
- RoomListSlot.cs
- RoomPlayerInfoSlot.cs
- SettingsManager.cs
- Singleton`1.cs
- UI_Base.cs
- UI_CharacterSelect.cs
- UI_ConfirmWindow.cs
- UI_CreateRoomOption.cs
- UI_ExitGame.cs
- UI_Lobby.cs
- UI_Manager.cs
- UI_Popup.cs
- UI_Room.cs
- UI_Screen.cs
- FinishLineTrigger.cs
- GamePlayManager.cs
- GamePlayWorkflow.cs
- LobbySceneWorkflow.cs
============================

// --- ClientCharacterController.cs ---
/*// 0115V2[CHANGED/ADDED code with comments]

using Photon;
using Photon.Pun;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.InputSystem; // [ADDED] New Input System

namespace Practices.PhotonPunClient.Network
{
    public class ClientCharacterController : MonoBehaviour, IPunInstantiateMagicCallback
    {
        // 멀티톤
        public static Dictionary<int, ClientCharacterController> controllers
            = new Dictionary<int, ClientCharacterController>();

        public int ownerActorNr => _photonView.OwnerActorNr;
        public int photonViewId => _photonView.ViewID;
        public bool isInitialized { get; private set; }
        public Pickable pickable { get; set; }

        PhotonView _photonView;
        NavMeshAgent _agent;

        // [CHANGED] New Input System: PlayerInput
        private PlayerInput _playerInput;
        private InputAction _inputActions; // [ADDED] 기존 InputActions
        private InputAction _leftClickAction;

        [SerializeField] LayerMask _groundMask;
        [SerializeField] LayerMask _pickable;
        [SerializeField] LayerMask _kickable;
        [SerializeField] Transform _rightHand;
        [SerializeField] Transform _leftHand;

        // [ADDED] 파쿠르/폴가이즈 스타일 속성
        [Header("Parkour Settings")]
        [SerializeField] float walkSpeed = 3.5f;
        [SerializeField] float sprintSpeed = 6f;
        [SerializeField] float jumpForce = 7f;
        [SerializeField] float rollDistance = 3f;
        // 상황에 따라 슬라이딩, 벽잡기 등 추가

        bool isSprinting = false;

        private void Awake()
        {
            _photonView = GetComponent<PhotonView>();
            _agent = GetComponent<NavMeshAgent>();

            // [ADDED] PlayerInput 컴포넌트 찾기
            _playerInput = GetComponent<PlayerInput>();
            if (_playerInput != null)
            {
                // 예: InputActions에 "LeftClick" 액션이 존재해야 함
                _leftClickAction = _playerInput.actions["LeftClick"];
            }
            else
            {
                Debug.LogError("PlayerInput component not found!");
            }
        }

        private void OnEnable()
        {
            if (_leftClickAction != null)
            {
                _leftClickAction.performed += OnLeftClickHandler;
                _leftClickAction.Enable();
            }
            // [ADDED] Enable our custom input actions
            SetupParkourActions(true);
        }

        private void OnDisable()
        {
            if (_leftClickAction != null)
            {
                _leftClickAction.performed -= OnLeftClickHandler;
                _leftClickAction.Disable();
            }
            // [ADDED] Disable our custom input actions
            SetupParkourActions(false);
        }

        private void OnDestroy()
        {
            if (_leftClickAction != null)
            {
                _leftClickAction.performed -= OnLeftClickHandler;
            }
        }

        // [ADDED] 파쿠르 입력 설정 (WASD, Shift, Space, Ctrl 등)
        void SetupParkourActions(bool enable)
        {
            if (_inputActions == null) return; // PhotonView 소유자가 아니면 null 일수 있음

            if (enable)
            {
                // 이동(WASD), 스프린트(Shift), 점프(Space), 구르기(Ctrl) 등
                _inputActions.Player.Move.Enable();
                _inputActions.Player.Sprint.performed += OnSprintPerformed;
                _inputActions.Player.Sprint.canceled += OnSprintCanceled;

                _inputActions.Player.Jump.performed += OnJump;
                _inputActions.Player.Roll.performed += OnRoll;

                // 균형 잡기(Q/E), 상호작용(F), 던지기(R) 등
                _inputActions.Player.LeanLeft.performed += OnLeanLeft;
                _inputActions.Player.LeanRight.performed += OnLeanRight;
                _inputActions.Player.Interact.performed += OnInteract;
                _inputActions.Player.ThrowItem.performed += OnThrowItem;

                _inputActions.Player.Move.Enable();
                _inputActions.Player.Sprint.Enable();
                _inputActions.Player.Jump.Enable();
                _inputActions.Player.Roll.Enable();
                _inputActions.Player.LeanLeft.Enable();
                _inputActions.Player.LeanRight.Enable();
                _inputActions.Player.Interact.Enable();
                _inputActions.Player.ThrowItem.Enable();
            }
            else
            {
                _inputActions.Player.Move.Disable();
                _inputActions.Player.Sprint.performed -= OnSprintPerformed;
                _inputActions.Player.Sprint.canceled -= OnSprintCanceled;

                _inputActions.Player.Jump.performed -= OnJump;
                _inputActions.Player.Roll.performed -= OnRoll;

                _inputActions.Player.LeanLeft.performed -= OnLeanLeft;
                _inputActions.Player.LeanRight.performed -= OnLeanRight;
                _inputActions.Player.Interact.performed -= OnInteract;
                _inputActions.Player.ThrowItem.performed -= OnThrowItem;

                _inputActions.Player.Sprint.Disable();
                _inputActions.Player.Jump.Disable();
                _inputActions.Player.Roll.Disable();
                _inputActions.Player.LeanLeft.Disable();
                _inputActions.Player.LeanRight.Disable();
                _inputActions.Player.Interact.Disable();
                _inputActions.Player.ThrowItem.Disable();
            }
        }

        public void OnLeftClickHandler(InputAction.CallbackContext context)
        {
            if (this == null) return;
            Debug.Log("LeftClick performed via PlayerInput");

            // [ADDED] 여기서도 '잡기' 또는 '밀기'로 사용할 수 있음
            // 만약 pickable과 로직이 충돌하면, OnLeftClick(InputAction.CallbackContext) 기존 코드를 참조
        }

        public Transform GetEmptyHand()
        {
            return _rightHand; // 일단 오른손 사용
        }

        public void OnPhotonInstantiate(PhotonMessageInfo info)
        {
            PhotonNetwork.LocalPlayer.SetCustomProperties(new ExitGames.Client.Photon.Hashtable
            {
                { PlayerInGamePlayPropertyKey.IS_CHARACTER_SPAWNED, true }
            });

            isInitialized = true;

            if (_photonView.IsMine)
            {
                _agent.enabled = true;

                // [CHANGED] 기존 InputActions 직접 Enable
                _inputActions = new InputActions();
                _inputActions.Player.Fire.performed += OnLeftClick;
                _inputActions.Player.MouseRight.performed += OnRightClick;
                _inputActions.Enable();
            }
            else
            {
                _agent.enabled = false;
            }

            controllers.Add(_photonView.OwnerActorNr, this);
            Debug.Log($"[ClientCharacterController] Instantiated. Actor={_photonView.OwnerActorNr}");
        }

        // [CHANGED] 기존 Mouse LeftClick - "Fire" -> OnLeftClick
        void OnLeftClick(InputAction.CallbackContext context)
        {
            if (pickable)
            {
                pickable.Drop();
                return;
            }
            else
            {
                Collider[] cols = Physics.OverlapSphere(transform.position, 1f, _pickable);
                if (cols.Length > 0)
                {
                    cols[0].GetComponent<Pickable>().PickUp();
                    return;
                }
            }

            if (Physics.SphereCast(transform.position, 1f, transform.forward, out RaycastHit hit, 1f, _kickable))
            {
                Kickable kickable = hit.collider.GetComponent<Kickable>();
                kickable.Kick((hit.point - transform.position) * 3f);
            }
        }

        // [CHANGED] 기존 Mouse RightClick - "MouseRight" -> OnRightClick
        void OnRightClick(InputAction.CallbackContext context)
        {
            if (!_photonView.IsMine) return;
            Ray ray = Camera.main.ScreenPointToRay(Mouse.current.position.ReadValue());
            Debug.DrawRay(ray.origin, ray.direction);

            if (Physics.Raycast(ray, out RaycastHit hit, float.PositiveInfinity, _groundMask))
            {
                _agent.SetDestination(hit.point);
            }
        }

        // [ADDED] 파쿠르 함수들
        void OnSprintPerformed(InputAction.CallbackContext ctx)
        {
            isSprinting = true;
            _agent.speed = sprintSpeed;
        }
        void OnSprintCanceled(InputAction.CallbackContext ctx)
        {
            isSprinting = false;
            _agent.speed = walkSpeed;
        }

        void OnJump(InputAction.CallbackContext ctx)
        {
            // 점프 (NavMeshAgent 쓰면 물리 점프 구현이 좀 까다롭지만 예시)
            Debug.Log("Jump pressed!");
            // NavMeshAgent로는 점프 적용이 어려우니, 임시로...
            // TODO: 직접 Rigidbody.AddForce or CharacterController
        }

        void OnRoll(InputAction.CallbackContext ctx)
        {
            // 구르기 (Ctrl)
            Debug.Log("Roll performed!");
            // TODO: 애니메이션, 이동 처리
        }

        void OnLeanLeft(InputAction.CallbackContext ctx)
        {
            Debug.Log("Lean Left (Q)");
            // 좁은 다리 등에서 균형 기울이기
        }

        void OnLeanRight(InputAction.CallbackContext ctx)
        {
            Debug.Log("Lean Right (E)");
        }

        void OnInteract(InputAction.CallbackContext ctx)
        {
            Debug.Log("Interact(F) pressed");
            // 아이템 줍기, 문 열기 등
        }

        void OnThrowItem(InputAction.CallbackContext ctx)
        {
            Debug.Log("Throw(R) pressed");
            // 잡은 아이템 던지기
        }
    }
}*/





// 0116-V2 [CHANGED/ADDED code with comments]

using Photon;
using Photon.Pun;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.InputSystem;  // [ADDED] New Input System

namespace Practices.PhotonPunClient.Network
{
    public class ClientCharacterController : MonoBehaviour, IPunInstantiateMagicCallback
    {
        // 멀티톤
        public static Dictionary<int, ClientCharacterController> controllers
            = new Dictionary<int, ClientCharacterController>();

        public int ownerActorNr => _photonView.OwnerActorNr;
        public int photonViewId => _photonView.ViewID;
        public bool isInitialized { get; private set; }
        
        //public Pickable pickable { get; set; }

        PhotonView _photonView;
        NavMeshAgent _agent;

        // [CHANGED] New Input System: PlayerInput
        private PlayerInput _playerInput;

        // [CHANGED] 자동 생성된 클래스 이름이 "PlayerInputActions"라고 가정
        private PlayerInputActions _inputActions;

        // [ADDED] WASD 움직임을 위한 액션
        private InputAction _moveAction; // Move (Vector2)

        [SerializeField] LayerMask _groundMask;
        [SerializeField] LayerMask _pickable;
        [SerializeField] LayerMask _kickable;
        [SerializeField] Transform _rightHand;
        [SerializeField] Transform _leftHand;

        // [ADDED] 이동속도
        [SerializeField] float moveSpeed = 3.5f;

        private void Awake()
        {
            _photonView = GetComponent<PhotonView>();
            _agent = GetComponent<NavMeshAgent>();

            // [CHANGED] PlayerInput 컴포넌트 찾기
            _playerInput = GetComponent<PlayerInput>();
            if (_playerInput != null)
            {
                // .inputactions 파일에서 "Move" 액션이 존재한다고 가정
                _moveAction = _playerInput.actions["Move"];
                // (만약 "Move" 대신 다른 이름이면 코드 수정)
            }
            else
            {
                Debug.LogError("PlayerInput component not found!");
            }
        }

        private void OnEnable()
        {
            if (_moveAction != null)
            {
                // [ADDED] Move 액션의 performed/canceled 이벤트 등록
                _moveAction.performed += OnMovePerformed;
                _moveAction.canceled += OnMoveCanceled;
                _moveAction.Enable();
            }
        }

        private void OnDisable()
        {
            if (_moveAction != null)
            {
                _moveAction.performed -= OnMovePerformed;
                _moveAction.canceled -= OnMoveCanceled;
                _moveAction.Disable();
            }
        }

        private void OnDestroy()
        {
            // 이벤트 해제
            if (_moveAction != null)
            {
                _moveAction.performed -= OnMovePerformed;
                _moveAction.canceled -= OnMoveCanceled;
            }
        }

        // [ADDED] Move 액션 처리
        private void OnMovePerformed(InputAction.CallbackContext context)
        {
            if (!_photonView.IsMine) return; // 내 캐릭터만 제어

            // Vector2: (x = A/D, y = W/S)
            Vector2 input = context.ReadValue<Vector2>();
            // NavMeshAgent 이용: 현재 위치 + (방향 * 속도)
            Vector3 moveDir = new Vector3(input.x, 0f, input.y);

            // [CHANGED] NavMeshAgent 로 즉시 SetDestination
            // 단, 매 프레임마다 반복 호출은 과도할 수 있음 → 예시로 작성
            Vector3 targetPos = transform.position + moveDir * moveSpeed * Time.deltaTime;
            _agent.SetDestination(targetPos);
        }

        private void OnMoveCanceled(InputAction.CallbackContext context)
        {
            if (!_photonView.IsMine) return;

            // [ADDED] WASD 키에서 손 뗐을 때, 
            // 일단 현재 위치에 멈추도록 agent Destination을 자기 위치로 설정
            _agent.SetDestination(transform.position);
        }

        public Transform GetEmptyHand()
        {
            return _rightHand; // 일단 오른손 사용
        }

        public void OnPhotonInstantiate(PhotonMessageInfo info)
        {
            PhotonNetwork.LocalPlayer.SetCustomProperties(new ExitGames.Client.Photon.Hashtable
            {
                { PlayerInGamePlayPropertyKey.IS_CHARACTER_SPAWNED, true }
            });

            isInitialized = true;

            if (_photonView.IsMine)
            {
                _agent.enabled = true;

                // [CHANGED] PlayerInputActions 인스턴스 생성
                _inputActions = new PlayerInputActions();
                // [CHANGED] 원래 Fire/MouseRight 등 있었지만, 여기서는 WASD만 사용
                // _inputActions.Player.Fire.performed += ... 제거함

                _inputActions.Enable();
            }
            else
            {
                _agent.enabled = false;
            }

            controllers.Add(_photonView.OwnerActorNr, this);
            Debug.Log($"[ClientCharacterController] Instantiated. Actor={_photonView.OwnerActorNr}");
        }
    }
}




// --- PhotonCharacterControl.cs ---
using Photon.Pun;       // [ADDED] Photon
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Photon 환경에서 동작하는 캐릭터 컨트롤러 예시.
/// - 로컬 플레이어만 입력 + 카메라를 활성화한다.
/// - OwnershipTransfer=Fixed 시, 각 클라이언트가 직접 Instantiate 해야 자기 캐릭터가 IsMine.
/// </summary>
namespace Supercyan.FreeSample
{
    // [CHANGED] MonoBehaviourPun으로 교체 (PhotonView, photonView.IsMine 사용 위해)
    public class PhotonCharacterControl : MonoBehaviourPun
    {
        private enum ControlMode
        {
            /// <summary>
            /// Up=전진, Down=후진, Left/Right=회전 (탱크 컨트롤)
            /// </summary>
            Tank,

            /// <summary>
            /// 카메라 방향 기준, W/A/S/D 이동 (3인칭 일반)
            /// </summary>
            Direct
        }

        // --- 이동/점프 파라미터 ---
        [Header("Movement Settings")]
        [SerializeField] private float m_moveSpeed = 2f;
        [SerializeField] private float m_turnSpeed = 200f;
        [SerializeField] private float m_jumpForce = 4f;

        // --- 애니메이터, 리지드바디 등 ---
        [Header("Components")]
        [SerializeField] private Animator m_animator = null;
        [SerializeField] private Rigidbody m_rigidBody = null;

        [Header("Control Mode")]
        [SerializeField] private ControlMode m_controlMode = ControlMode.Direct;

        // --- 내부 변수 ---
        private float m_currentV = 0;
        private float m_currentH = 0;

        private readonly float m_interpolation = 10f;
        private readonly float m_walkScale = 0.33f;
        private readonly float m_backwardsWalkScale = 0.16f;
        private readonly float m_backwardRunScale = 0.66f;

        private bool m_wasGrounded;
        private Vector3 m_currentDirection = Vector3.zero;

        private float m_jumpTimeStamp = 0;
        private float m_minJumpInterval = 0.25f;
        private bool m_jumpInput = false;

        private bool m_isGrounded;
        private List<Collider> m_collisions = new List<Collider>();

        // [ADDED] 로컬 카메라. 캐릭터 프리팹에 붙은 카메라를 할당
        [Header("Local Camera")]
        [SerializeField] private Camera characterCamera = null;

        // [ADDED] 오디오 리스너도 필요하다면
        [SerializeField] private AudioListener audioListener = null;

        private void Awake()
        {
            // 혹시 Inspector에 빠져 있으면 GetComponent로 찾음
            if (!m_animator) m_animator = GetComponent<Animator>();
            if (!m_rigidBody) m_rigidBody = GetComponent<Rigidbody>();

            // [ADDED] 카메라/오디오가 없다면 시도해보기 (선택)
            // if (!characterCamera) characterCamera = GetComponentInChildren<Camera>();
            // if (!audioListener)   audioListener   = GetComponentInChildren<AudioListener>();

            // [ADDED] 내 캐릭터가 아니라면 카메라 비활성화
            if (!photonView.IsMine)
            {
                if (characterCamera)
                {
                    characterCamera.enabled = false;
                }
                if (audioListener)
                {
                    audioListener.enabled = false;
                }
            }
        }

        #region Ground Check
        private void OnCollisionEnter(Collision collision)
        {
            CheckCollisionGrounded(collision, true);
        }

        private void OnCollisionStay(Collision collision)
        {
            CheckCollisionGrounded(collision, false);
        }

        private void OnCollisionExit(Collision collision)
        {
            if (m_collisions.Contains(collision.collider))
            {
                m_collisions.Remove(collision.collider);
            }
            if (m_collisions.Count == 0)
            {
                m_isGrounded = false;
            }
        }

        private void CheckCollisionGrounded(Collision collision, bool onEnter)
        {
            ContactPoint[] contactPoints = collision.contacts;
            bool validNormal = false;

            for (int i = 0; i < contactPoints.Length; i++)
            {
                // 위 방향과 어느정도 일치하면 지면으로 판단
                if (Vector3.Dot(contactPoints[i].normal, Vector3.up) > 0.5f)
                {
                    validNormal = true;
                    break;
                }
            }

            if (validNormal)
            {
                m_isGrounded = true;
                if (onEnter && !m_collisions.Contains(collision.collider))
                {
                    m_collisions.Add(collision.collider);
                }
                else if (!onEnter && !m_collisions.Contains(collision.collider))
                {
                    m_collisions.Add(collision.collider);
                }
            }
            else
            {
                if (m_collisions.Contains(collision.collider))
                {
                    m_collisions.Remove(collision.collider);
                }
                if (m_collisions.Count == 0)
                {
                    m_isGrounded = false;
                }
            }
        }
        #endregion

        private void Update()
        {
            // [ADDED] 로컬 캐릭터만 입력 처리
            if (!photonView.IsMine) return;

            if (!m_jumpInput && Input.GetKey(KeyCode.Space))
            {
                m_jumpInput = true;
            }
        }

        private void FixedUpdate()
        {
            // [ADDED] 로컬 캐릭터만 이동 처리
            if (!photonView.IsMine) return;

            m_animator.SetBool("Grounded", m_isGrounded);

            switch (m_controlMode)
            {
                case ControlMode.Direct:
                    DirectUpdate();
                    break;

                case ControlMode.Tank:
                    TankUpdate();
                    break;

                default:
                    Debug.LogError("Unsupported state");
                    break;
            }

            m_wasGrounded = m_isGrounded;
            m_jumpInput = false;
        }

        private void TankUpdate()
        {
            float v = Input.GetAxis("Vertical");
            float h = Input.GetAxis("Horizontal");

            bool walk = Input.GetKey(KeyCode.LeftShift);

            if (v < 0)
            {
                if (walk) { v *= m_backwardsWalkScale; }
                else { v *= m_backwardRunScale; }
            }
            else if (walk)
            {
                v *= m_walkScale;
            }

            m_currentV = Mathf.Lerp(m_currentV, v, Time.deltaTime * m_interpolation);
            m_currentH = Mathf.Lerp(m_currentH, h, Time.deltaTime * m_interpolation);

            // 전/후진
            transform.position += transform.forward * m_currentV * m_moveSpeed * Time.deltaTime;
            // 좌/우 회전
            transform.Rotate(0, m_currentH * m_turnSpeed * Time.deltaTime, 0);

            m_animator.SetFloat("MoveSpeed", m_currentV);

            JumpingAndLanding();
        }

        private void DirectUpdate()
        {
            float v = Input.GetAxis("Vertical");
            float h = Input.GetAxis("Horizontal");

            // Shift누르면 걷기
            if (Input.GetKey(KeyCode.LeftShift))
            {
                v *= m_walkScale;
                h *= m_walkScale;
            }

            m_currentV = Mathf.Lerp(m_currentV, v, Time.deltaTime * m_interpolation);
            m_currentH = Mathf.Lerp(m_currentH, h, Time.deltaTime * m_interpolation);

            // 카메라 방향기준 이동
            Transform camera = Camera.main.transform;
            Vector3 direction = camera.forward * m_currentV + camera.right * m_currentH;

            float directionLength = direction.magnitude;
            direction.y = 0;
            direction = direction.normalized * directionLength;

            if (direction != Vector3.zero)
            {
                m_currentDirection = Vector3.Slerp(m_currentDirection, direction, Time.deltaTime * m_interpolation);

                transform.rotation = Quaternion.LookRotation(m_currentDirection);
                transform.position += m_currentDirection * m_moveSpeed * Time.deltaTime;

                m_animator.SetFloat("MoveSpeed", direction.magnitude);
            }

            JumpingAndLanding();
        }

        private void JumpingAndLanding()
        {
            bool jumpCooldownOver = (Time.time - m_jumpTimeStamp) >= m_minJumpInterval;

            if (jumpCooldownOver && m_isGrounded && m_jumpInput)
            {
                m_jumpTimeStamp = Time.time;
                m_rigidBody.AddForce(Vector3.up * m_jumpForce, ForceMode.Impulse);
            }
        }
    }
}


// --- PhotonCustomPropertyTypes.cs ---
namespace Practices.PhotonPunClient
{
    public static class PlayerInRoomPropertyKey
    {
        public const string IS_READY = "IsReady";
    }

    public static class PlayerInGamePlayPropertyKey
    {
        public const string IS_CHARACTER_SPAWNED = "IsCharacterSpawned";
    }
}

// --- PhotonEventCode.cs ---
namespace Practices.PhotonPunClient.Network
{
    public static class PhotonEventCode
    {
        public const byte SYNC_VIEW_ID = 1;
    }
}

// --- PhotonManager.cs ---
using Photon.Pun;
using UnityEngine;

namespace Practices.PhotonPunClient.Network
{
    public class PhotonManager : MonoBehaviourPunCallbacks
    {
        public static PhotonManager instance
        {
            get
            {
                if (s_instance == null)
                {
                    s_instance = new GameObject(nameof(PhotonManager)).AddComponent<PhotonManager>();
                }

                return s_instance;
            }
        }

        static PhotonManager s_instance;


        private void Awake()
        {
            if (s_instance)
            {
                Destroy(gameObject);
                return;
            }
            else
            {
                s_instance = this;
            }

            if (PhotonNetwork.IsConnected == false)
            {
#if UNITY_EDITOR
                PhotonNetwork.LogLevel = PunLogLevel.Full;
                Application.runInBackground = true;
#endif
                PhotonNetwork.AuthValues = new Photon.Realtime.AuthenticationValues(Random.Range(0, 999999999).ToString());
                PhotonNetwork.NickName = Random.Range(0, 999999999).ToString();
                bool isConnected = PhotonNetwork.ConnectUsingSettings();
                Debug.Assert(isConnected, $"[{nameof(PhotonManager)}] Failed to connect to photon pun server.");
            }

            DontDestroyOnLoad(gameObject);
        }

        public override void OnConnectedToMaster()
        {
            base.OnConnectedToMaster();
            
            PhotonNetwork.AutomaticallySyncScene = true; // 현재 속해있는 방의 방장이 씬을 전환하면 따라서 전환하는 옵션
            // PhotonNetwork.NickName
            Debug.Log($"[{nameof(PhotonManager)}] Connected to master server.");
            PhotonNetwork.JoinLobby();
        }

        public override void OnJoinedLobby()
        {
            base.OnJoinedLobby();
            Debug.Log($"[{nameof(PhotonManager)}] Joined lobby.");
        }
    }
}



// --- PunAutoSyncMonoBehaviour.cs ---
using ExitGames.Client.Photon;
using Photon.Pun;
using Photon.Realtime;
using UnityEngine;

namespace Practices.PhotonPunClient.Network
{
    /// <summary>
    /// 레벨에 미리 배치해둬야하는 동기화필요한 NetworkObject 들은
    /// PhotonNetwork.Instantiate 보다 단순 이벤트로 ViewID 만 동기화해주는것이 성능이 좋다. 
    /// (이미 동일한 GameObject 들로 생성이 되어있기 때문에)
    /// </summary>
    [RequireComponent(typeof(PhotonView))]
    public abstract class PunAutoSyncMonobehaviour : MonoBehaviour, IOnEventCallback
    {
        protected PhotonView photonView;

        protected virtual void Awake()
        {
            photonView = GetComponent<PhotonView>();
            SyncViewID();
        }

        protected virtual void OnEnable()
        {
            PhotonNetwork.AddCallbackTarget(this);
        }

        protected virtual void OnDisable()
        {
            PhotonNetwork.RemoveCallbackTarget(this);
        }

        void SyncViewID()
        {
            if (PhotonNetwork.IsMasterClient == false)
                return;

            if (photonView.Owner != null)
                return;

            if (PhotonNetwork.AllocateViewID(photonView))
            {
                object raiseEventContent = new object[]
                {
                    photonView.ViewID,
                };

                RaiseEventOptions raiseEventOption = new RaiseEventOptions
                {
                    Receivers = ReceiverGroup.Others,
                };

                PhotonNetwork.RaiseEvent(PhotonEventCode.SYNC_VIEW_ID,
                                         raiseEventContent,
                                         raiseEventOption,
                                         SendOptions.SendReliable);
            }
            else
            {
                throw new System.Exception($"[{nameof(PunAutoSyncMonobehaviour)}] Failed to sync view id...");
            }
        }

        public void OnEvent(EventData photonEvent)
        {
            byte eventCode = photonEvent.Code;

            if (eventCode == PhotonEventCode.SYNC_VIEW_ID)
                HandleSyncViewIdEvent(photonEvent);
        }

        void HandleSyncViewIdEvent(EventData photonEvent) 
        {
            object[] data = (object[])photonEvent.CustomData;
            int viewId = (int)data[0];
            photonView.ViewID = viewId;
        }
    }
}

// --- GameTimerUI.cs ---
// [ADDED FILE] GameTimerUI.cs
// Canvas + TMP_Text 오브젝트에 연결 후, _timerText에 참조
using Photon.Pun;
using UnityEngine;
using TMPro;

public class GameTimerUI : MonoBehaviourPun
{
    [SerializeField] TMP_Text _timerText;

    double _startTime;

    void Start()
    {
        if (PhotonNetwork.IsMasterClient)
        {
            _startTime = PhotonNetwork.Time;
            photonView.RPC(nameof(SyncStartTime), RpcTarget.Others, _startTime);
        }
    }

    [PunRPC]
    void SyncStartTime(double t)
    {
        _startTime = t;
    }

    void Update()
    {
        if (_startTime > 0)
        {
            double elapsed = PhotonNetwork.Time - _startTime;
            _timerText.text = $"Time: {elapsed:F2}";
        }
    }
}

// --- LobbyGameManager.cs ---
using Photon.Pun;    // [ADDED] Photon
using Photon.Realtime;
using UnityEngine;
using UnityEngine.UI;

public class LobbyGameManager : MonoBehaviourPunCallbacks
{
    // [CHANGED] 씬에 배치된 "로비 카메라"와 "로비 UI"를 참조
    [Header("Lobby Objects")]
    [SerializeField] private Camera lobbyCamera = null;    // 씬에 있는 카메라(메인 카메라 역할)
    [SerializeField] private Canvas lobbyCanvas = null;    // 로비 UI (방 목록, 버튼 등등)

    [Header("UI Buttons")]
    [SerializeField] private Button startGameButton = null; // "게임시작" 버튼

    [Header("Photon Settings")]
    [SerializeField] private string characterPrefabName = "Archer";
    // Resources/Characters/Archer 등 실제 경로 맞게 설정

    private bool isGameStarted = false;  // 로비 vs 게임 상태 판단용

    private void Start()
    {
        // [CHANGED] 로비 상태 초기화
        isGameStarted = false;

        // 로비카메라, 로비Canvas 켜기
        if (lobbyCamera) lobbyCamera.gameObject.SetActive(true);
        if (lobbyCanvas) lobbyCanvas.gameObject.SetActive(true);

        // 게임 시작 버튼 리스너
        if (startGameButton)
        {
            startGameButton.onClick.AddListener(OnClickStartGame);
        }
    }

    // [CHANGED] "StartGame" 버튼 클릭 시 호출
    private void OnClickStartGame()
    {
        if (isGameStarted) return;

        isGameStarted = true;

        // 로비 카메라와 UI 끄기
        if (lobbyCamera) lobbyCamera.gameObject.SetActive(false);
        if (lobbyCanvas) lobbyCanvas.gameObject.SetActive(false);

        // PhotonNetwork.Instantiate를 통해 캐릭터 생성
        // 실제로는 Vector3, Quaternion값을 원하는 스폰 위치/회전으로 조정
        Vector3 spawnPos = new Vector3(Random.Range(-3f, 3f), 0f, Random.Range(-3f, 3f));
        Quaternion spawnRot = Quaternion.identity;

        PhotonNetwork.Instantiate(characterPrefabName, spawnPos, spawnRot);
        // => 캐릭터 프리팹에 카메라가 들어있고, photonView.IsMine == true인 오브젝트만
        //    카메라.enabled = true 등으로 로컬 시점을 갖게 됨
    }

    // [CHANGED] Photon 콜백 (예: 다른 유저가 나갔을 때 등)
    public override void OnPlayerLeftRoom(Player otherPlayer)
    {
        base.OnPlayerLeftRoom(otherPlayer);
        Debug.Log($"[LobbyGameManager] Player left: {otherPlayer.NickName}");
    }

    // [CHANGED] Optional: 게임이 끝나고 로비로 복귀하는 로직
    // 하나의 씬에서 로비로 돌아가려면?
    public void ReturnToLobby()
    {
        // 캐릭터, 게임오브젝트 정리
        // PhotonNetwork.Destroy(??) 등...

        isGameStarted = false;

        // 로비카메라, 로비UI 다시 켜기
        if (lobbyCamera) lobbyCamera.gameObject.SetActive(true);
        if (lobbyCanvas) lobbyCanvas.gameObject.SetActive(true);
    }
}


// --- RoomListSlot.cs ---
using UnityEngine;
using Practices.UGUI_Management.UI;
using Practices.UGUI_Management.Utilities;
using TMPro;
using UnityEngine.UI;

namespace Practices.PhotonPunClient.UI
{
    public class RoomListSlot : ComponentResolvingBehaviour
    {
        public bool isSelected
        {
            get => _isSelectedValue;
            set
            {
                _isSelectedValue = value;
                _isSelected.gameObject.SetActive(value);
            }
        }

        public int roomId
        {
            get => _roomIdValue;
            set
            {
                _roomIdValue = value;
                _roomId.text = value.ToString();
            }
        }

        public string roomName
        {
            get => _roomNameValue;
            set
            {
                _roomNameValue = value;
                _roomName.text = value.ToString();
            }
        }

        public int roomPlayerCount
        {
            get => _roomPlayerCountValue;
            set
            {
                _roomPlayerCountValue = value;
                _roomPlayerCount.text = value.ToString();
            }
        }

        public int roomMaxPlayers
        {
            get => _roomMaxPlayersValue;
            set
            {
                _roomMaxPlayersValue = value;
                _roomMaxPlayers.text = value.ToString();
            }
        }

        bool _isSelectedValue;
        int _roomIdValue;
        string _roomNameValue;
        int _roomPlayerCountValue;
        int _roomMaxPlayersValue;
        [Resolve] Image _isSelected;
        [Resolve] TMP_Text _roomId;
        [Resolve] TMP_Text _roomName;
        [Resolve] TMP_Text _roomPlayerCount;
        [Resolve] TMP_Text _roomMaxPlayers;
    }
}

// --- RoomPlayerInfoSlot.cs ---
using UnityEngine;
using Practices.UGUI_Management.Utilities;
using TMPro;
using UnityEngine.UI;

namespace Practices.PhotonPunClient.UI
{
    public class RoomPlayerInfoSlot : ComponentResolvingBehaviour
    {
        public int actorNumber { get; set; }

        public bool isReady
        {
            get => _isReadyValue;
            set
            {
                _isReadyValue = value;
                _isReady.gameObject.SetActive(value);
            }
        }

        public string playerName
        {
            get => _playerNameValue;
            set
            {
                _playerName.text = value;
            }
        }

        public bool isMasterClient
        {
            get => _isMasterClientValue;
            set
            {
                _isMasterClientValue = value;
                _isMasterClient.gameObject.SetActive(value);
            }
        }


        bool _isReadyValue;
        string _playerNameValue;
        bool _isMasterClientValue;
        [Resolve] TMP_Text _isReady;
        [Resolve] TMP_Text _playerName;
        [Resolve] Image _isMasterClient;
    }
}

// --- SettingsManager.cs ---
using UnityEngine;
using UnityEngine.UI;

public class SettingsManager : MonoBehaviour
{
    // 설정창 Canvas (비활성화/활성화할 대상)
    [SerializeField] private GameObject canvasSettings;

    // 로비에서 설정창을 여는 버튼
    [SerializeField] private Button optionsButton;

    // 설정창에서 설정을 닫는 버튼
    [SerializeField] private Button confirmButton;

    // 게임을 종료하는 Exit 버튼
    [SerializeField] private Button exitButton;

    private void Start()
    {
        // 설정창을 처음에는 비활성화 상태로 설정
        if (canvasSettings != null)
            canvasSettings.SetActive(false);
        else
            Debug.LogError("Canvas Settings가 연결되지 않았습니다!");

        // 옵션 버튼 클릭 시 설정창 토글
        if (optionsButton != null)
            optionsButton.onClick.AddListener(ToggleSettings);
        else
            Debug.LogError("Options Button이 연결되지 않았습니다!");

        // 확인 버튼 클릭 시 설정창 닫기
        if (confirmButton != null)
            confirmButton.onClick.AddListener(ToggleSettings);
        else
            Debug.LogError("Confirm Button이 연결되지 않았습니다!");

        // Exit 버튼 클릭 시 게임 종료
        if (exitButton != null)
            exitButton.onClick.AddListener(ExitGame);
        else
            Debug.LogError("Exit Button이 연결되지 않았습니다!");
    }

    /// <summary>
    /// 설정창의 활성화/비활성화 상태를 토글합니다.
    /// </summary>
    private void ToggleSettings()
    {
        if (canvasSettings != null)
        {
            // 현재 상태 반대로 토글
            bool isActive = canvasSettings.activeSelf;
            canvasSettings.SetActive(!isActive);
        }
        else
        {
            Debug.LogError("Canvas Settings가 설정되지 않았습니다!");
        }
    }

    /// <summary>
    /// 게임을 종료합니다.
    /// </summary>
    private void ExitGame()
    {
        Debug.Log("게임 종료 버튼이 눌렸습니다!");

#if UNITY_EDITOR
        // 에디터에서 실행 중인 경우 플레이 모드를 중지
        UnityEditor.EditorApplication.isPlaying = false;
#else
        // 빌드된 게임에서 프로그램 종료
        Application.Quit();
#endif
    }
}


// --- Singleton`1.cs ---
using System;
using System.Reflection;

namespace Practices.UGUI_Management.Singletons
{
    /// <summary>
    /// Singleton base
    /// </summary>
    /// <typeparam name="T"> 싱글톤으로 사용하려는 타입 (상속클래스) </typeparam>
    public abstract class Singleton<T>
        where T : Singleton<T>
    {
        public static T instance
        {
            get
            {
                if (s_instance == null)
                {
                    //ConstructorInfo constructorInfo = typeof(T).GetConstructor(new Type[] { });
                    //s_instance = (T)constructorInfo.Invoke(null);

                    s_instance = (T)Activator.CreateInstance(typeof(T));
                }

                return s_instance;
            }
        }


        private static T s_instance;
    }
}

// --- UI_Base.cs ---
// --- UI_Base.cs ---
using Practices.UGUI_Management.Utilities;
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.InputSystem;
using UnityEngine.UI;

namespace Practices.UGUI_Management.UI
{
    [RequireComponent(typeof(Canvas))]
    public abstract class UI_Base : ComponentResolvingBehaviour
    {
        public int sortingOrder
        {
            get => _canvas ? _canvas.sortingOrder : 0;  // [ADDED] null 체크
            set { if (_canvas) _canvas.sortingOrder = value; }
        }

        public bool inputActionsEnabled
        {
            get => playerInputActions.asset.enabled;
            set
            {
                if (value)
                    playerInputActions.Enable();
                else
                    playerInputActions.Disable();
            }
        }

        protected UI_Manager manager;
        protected PlayerInputActions playerInputActions;
        Canvas _canvas;
        GraphicRaycaster _graphicRaycaster;
        EventSystem _eventSystem;
        PointerEventData _pointerEventData;
        List<RaycastResult> _raycastResultBuffer;

        public event Action onShow;
        public event Action onHide;

        protected override void Awake()
        {
            base.Awake();

            _canvas = GetComponent<Canvas>();
            _graphicRaycaster = GetComponent<GraphicRaycaster>();
            _eventSystem = EventSystem.current;
            _pointerEventData = new PointerEventData(_eventSystem);
            _raycastResultBuffer = new List<RaycastResult>(1);

            playerInputActions = new PlayerInputActions();
            manager = UI_Manager.instance;
            manager.Register(this);
        }

        protected virtual void Start() { }

        // [ADDED] null 체크
        public virtual void Show()
        {
            if (!this || !_canvas) // 이미 Destroy되었거나, Canvas가 null
            {
                Debug.LogWarning($"[UI_Base] Attempted Show(), but is destroyed or _canvas is null. name={name}");
                return;
            }

            _canvas.enabled = true;
            onShow?.Invoke();
        }

        // [ADDED] null 체크
        public virtual void Hide()
        {
            if (!this || !_canvas) // 이미 Destroy되었거나 Null
            {
                Debug.LogWarning($"[UI_Base] Canvas is null or destroyed! Cannot Hide {name}");
                return;
            }

            _canvas.enabled = false;
            onHide?.Invoke();
        }

        public bool TryGraphicRaycast<T>(Vector2 pointerPosition, out T result)
            where T : Component
        {
            if (!_graphicRaycaster)
            {
                result = default;
                return false;
            }

            _pointerEventData.position = pointerPosition;
            _raycastResultBuffer.Clear();
            _graphicRaycaster.Raycast(_pointerEventData, _raycastResultBuffer);

            if (_raycastResultBuffer.Count > 0)
            {
                if (_raycastResultBuffer[0].gameObject.TryGetComponent(out result))
                    return true;
            }

            result = default;
            return false;
        }
    }
}




/*// [ADDED]250116V1
using Practices.UGUI_Management.Utilities;
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.InputSystem;
using UnityEngine.UI;

namespace Practices.UGUI_Management.UI
{
    [RequireComponent(typeof(Canvas))]
    public abstract class UI_Base : ComponentResolvingBehaviour
    {
        public int sortingOrder
        {
            get => _canvas.sortingOrder;
            set => _canvas.sortingOrder = value;
        }

        public bool inputActionsEnabled
        {
            get => playerInputActions.asset.enabled;
            set
            {
                if (value)
                    playerInputActions.Enable();
                else
                    playerInputActions.Disable();
            }
        }

        protected UI_Manager manager;
        protected PlayerInputActions playerInputActions;
        Canvas _canvas;
        GraphicRaycaster _graphicRaycaster;
        EventSystem _eventSystem;
        PointerEventData _pointerEventData;
        List<RaycastResult> _raycastResultBuffer;

        public event Action onShow;
        public event Action onHide;


        protected override void Awake()
        {
            base.Awake();

            _canvas = GetComponent<Canvas>();
            _graphicRaycaster = GetComponent<GraphicRaycaster>();
            _eventSystem = EventSystem.current;
            _pointerEventData = new PointerEventData(_eventSystem);
            _raycastResultBuffer = new List<RaycastResult>(1);
            playerInputActions = new PlayerInputActions();
            manager = UI_Manager.instance;
            manager.Register(this);
        }

        protected virtual void Start() { }

        public virtual void Show()
        {
            _canvas.enabled = true;
            onShow?.Invoke();
        }

        public virtual void Hide()
        {
            _canvas.enabled = false;
            onHide?.Invoke();
        }

        /// <summary>
        /// 현재 Canvas 에 특정 컴포넌트가 존재하는지 탐색
        /// </summary>
        /// <typeparam name="T"> 탐색하고싶은 컴포넌트 타입 </typeparam>
        /// <param name="pointerPosition"> 탐색하고싶은 위치 </param>
        /// <param name="result"> 탐색 반환결과 </param>
        /// <returns> 탐색 성공여부 </returns>
        public bool TryGraphicRaycast<T>(Vector2 pointerPosition, out T result)
            where T : Component
        {
            _pointerEventData.position = pointerPosition;
            _raycastResultBuffer.Clear();
            _graphicRaycaster.Raycast(_pointerEventData, _raycastResultBuffer);

            if (_raycastResultBuffer.Count > 0)
            {
                if (_raycastResultBuffer[0].gameObject.TryGetComponent(out result))
                    return true;
            }

            result = default;
            return false;
        }
    }
}*/

// --- UI_CharacterSelect.cs ---
// [ADDED FILE] UI_CharacterSelect.cs
using Photon.Pun;
using Photon.Realtime;
using Practices.UGUI_Management.UI;
using UnityEngine;
using UnityEngine.UI;

namespace Practices.PhotonPunClient.UI
{
    public class UI_CharacterSelect : UI_Popup // [ADDED] UI_Popup 상속(혹은 UI_Base)
    {
        [SerializeField] private Button[] _characterButtons;
        // 인스펙터에서 8개 버튼 등록 (ArcherBtn, ClericBtn, ...)

        private readonly string[] _characterNames =
        {
            "Archer",
            "Cleric",
            "Gunner",
            "Knight",
            "Mage",
            "Ninja",
            "Rogue",
            "Warrior"
        };

        protected override void Start()
        {
            base.Start();

            for (int i = 0; i < _characterButtons.Length; i++)
            {
                int idx = i; // capture
                _characterButtons[i].onClick.AddListener(() => OnClickCharacter(idx));
            }
        }

        private void OnClickCharacter(int idx)
        {
            if (idx < 0 || idx >= _characterNames.Length) return;

            string selected = _characterNames[idx];

            // [ADDED] Photon CustomProperties 저장
            var props = new ExitGames.Client.Photon.Hashtable
            {
                { "SelectedCharacter", selected }
            };
            PhotonNetwork.LocalPlayer.SetCustomProperties(props);

            Debug.Log($"[UI_CharacterSelect] Selected Character = {selected}");
        }
    }
}


// --- UI_ConfirmWindow.cs ---
using Practices.UGUI_Management.Utilities;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

namespace Practices.UGUI_Management.UI
{
    public class UI_ConfirmWindow : UI_Popup
    {
        [Resolve] TMP_Text _message;
        [Resolve] Button _confirm;

        public void Show(string message, UnityAction onConfirmed = null)
        {
            // [ADDED] �켱, �̹� �ı��Ǿ�����(=this == null) Ȥ�� Canvas�� ����ִ��� �˻�
            if (this == null)
            {
                Debug.LogWarning("[UI_ConfirmWindow] Attempting to Show(), but this is null/destroyed.");
                return;
            }

            // base.Show() ���ο��� _canvas.enabled = true; ���� ȣ��
            // base.Show() ȣ�� ��, canvas�� �����ϴ��� üũ( UI_Base ������ �ʿ��� ���� )
            // �Ʒ�ó�� UI_Popup, UI_Base �ʿ��� null-check �� ���� �ֽ��ϴ�.

            base.Show(); // <-- ���� ���⼭ MissingReference�� ��ٸ�, UI_Base�� UI_Popup���� canvas null üũ �ʿ�.

            if (this == null)
            {
                Debug.LogWarning("[UI_ConfirmWindow] After base.Show(), this is destroyed?");
                return;
            }

            if (_message == null || _confirm == null)
            {
                Debug.LogWarning("[UI_ConfirmWindow] _message or _confirm is null. Possibly destroyed?");
                return;
            }

            _message.text = message;
            _confirm.onClick.RemoveAllListeners();
            _confirm.onClick.AddListener(Hide);

            if (onConfirmed != null)
                _confirm.onClick.AddListener(onConfirmed);
        }
    }
}




/* //240116-V1
using Practices.UGUI_Management.Utilities;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

namespace Practices.UGUI_Management.UI
{
    public class UI_ConfirmWindow : UI_Popup
    {
        [Resolve] TMP_Text _message;
        [Resolve] Button _confirm;


        public void Show(string message, UnityAction onConfirmed = null)
        {
            base.Show();

            _message.text = message;
            _confirm.onClick.RemoveAllListeners();
            _confirm.onClick.AddListener(Hide);

            if (onConfirmed != null) 
                _confirm.onClick.AddListener(onConfirmed);
        }
    }
}*/

// --- UI_CreateRoomOption.cs ---
using Photon.Pun;
using Photon.Realtime;
using Practices.UGUI_Management.UI;
using Practices.UGUI_Management.Utilities;
using TMPro;
using UnityEngine.UI;

namespace Practices.PhotonPunClient.UI
{
    public class UI_CreateRoomOption : UI_Popup
    {
        [Resolve] TMP_InputField _roomName;
        [Resolve] TMP_InputField _roomMaxPlayers;
        [Resolve] Button _confirm;
        [Resolve] Button _cancel;

        const int ROOM_MAX_PLAYERS_LIMIT_MAX = 8;
        const int ROOM_MAX_PLAYERS_LIMIT_MIN = 2;


        protected override void Start()
        {
            base.Start();

            _roomMaxPlayers.onValueChanged.AddListener(value =>
            {
                if (int.TryParse(value, out int parsed))
                {
                    if (parsed > ROOM_MAX_PLAYERS_LIMIT_MAX)
                        _roomMaxPlayers.SetTextWithoutNotify(ROOM_MAX_PLAYERS_LIMIT_MAX.ToString()); // text property에 쓰면 무한루프걸림.
                    if (parsed < ROOM_MAX_PLAYERS_LIMIT_MIN)
                        _roomMaxPlayers.SetTextWithoutNotify(ROOM_MAX_PLAYERS_LIMIT_MIN.ToString()); // text property에 쓰면 무한루프걸림.
                }
                else
                {
                    _roomMaxPlayers.SetTextWithoutNotify(ROOM_MAX_PLAYERS_LIMIT_MIN.ToString());
                }
            });

            _confirm.onClick.AddListener(() =>
            {
                RoomOptions roomOptions = new RoomOptions();
                roomOptions.MaxPlayers = int.Parse(_roomMaxPlayers.text);
                PhotonNetwork.CreateRoom(_roomName.text, roomOptions);
                Hide();
            });

            _cancel.onClick.AddListener(Hide);
        }

        public override void Show()
        {
            base.Show();

            _roomName.text = string.Empty;
            _roomMaxPlayers.text = ROOM_MAX_PLAYERS_LIMIT_MIN.ToString();
        }
    }
}

// --- UI_ExitGame.cs ---
using Photon.Pun;
using Practices.UGUI_Management.UI;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

namespace Practices.PhotonPunClient.UI
{
    // Photon 콜백 사용을 위해 MonoBehaviourPunCallbacks 상속
    public class UI_ExitGame : MonoBehaviourPunCallbacks
    {
        [SerializeField] private Button _exitButton;
        // Button을 Inspector에서 참조할 수 있도록 SerializeField

        private void Start()
        {
            // 버튼이 누락되지 않았는지 체크
            if (_exitButton == null)
            {
                Debug.LogError($"[{nameof(UI_ExitGame)}] _exitButton is not assigned!");
                return;
            }

            // onClick 에 메서드 바인딩
            _exitButton.onClick.AddListener(OnClickExitGame);
        }

        /// <summary>
        /// 종료 버튼 클릭 시 호출
        /// </summary>
        private void OnClickExitGame()
        {
            // Photon 방을 떠나는 로직
            // 방에서 나가면 OnLeftRoom 콜백이 자동 호출됩니다.
            PhotonNetwork.LeaveRoom();

            // (선택) Photon 서버에서 연결을 끊고 싶다면
            // (선택) UI_Lobby, UI_ConfirmWindow 등이 혹시 DontDestroyOnLoad라면 여기서 Destroy
           /* var uiLobby = UI_Manager.instance.Resolve<UI_Lobby>();
            if (uiLobby != null)
            {
                // 만약 UI_Manager에 Deregister 메서드가 없다면
                // UI_Manager.instance.Deregister(uiLobby); (직접 구현 필요)
                Destroy(uiLobby.gameObject);
            }

            var uiConfirm = UI_Manager.instance.Resolve<UI_ConfirmWindow>();
            if (uiConfirm != null) Destroy(uiConfirm.gameObject);*/
        }

        /// <summary>
        /// Photon 룸을 떠난 뒤에 호출되는 콜백
        /// </summary>
        public override void OnLeftRoom()
        {
            base.OnLeftRoom();

            // Lobby 씬으로 돌아가거나, 원하는 씬으로 이동
            SceneManager.LoadScene("Lobby");
        }
    }
}


// --- UI_Lobby.cs ---
using Photon.Pun;
using Photon.Realtime;
using Practices.UGUI_Management.UI;
using Practices.UGUI_Management.Utilities;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

namespace Practices.PhotonPunClient.UI
{
    public class UI_Lobby : UI_Screen, ILobbyCallbacks, IMatchmakingCallbacks
    {
        [Resolve] RectTransform _roomListSlotContent;
        [Resolve] RoomListSlot _roomListSlot;
        [Resolve] Button _createRoom;
        [Resolve] Button _joinRoom;
        List<RoomListSlot> _roomListSlots = new List<RoomListSlot>(10);
        List<RoomInfo> _roomInfosCached = new List<RoomInfo>(10);
        int _roomIdSelected = -1;

        [Resolve] private Button _openCharacterSelectButton; // �ν����Ϳ��� ����

        protected override void Start()
        {
            base.Start();

            _roomListSlot.gameObject.SetActive(false);
            playerInputActions.UI.Click.performed += OnClick;
            _createRoom.onClick.AddListener(() =>
            {
                UI_CreateRoomOption createRoomOption = UI_Manager.instance.Resolve<UI_CreateRoomOption>();
                createRoomOption.Show();
            });

            _joinRoom.interactable = false;
            _joinRoom.onClick.AddListener(() =>
            {
                UI_ConfirmWindow confirmWindow = UI_Manager.instance.Resolve<UI_ConfirmWindow>();
                RoomInfo roomInfo = _roomInfosCached[_roomIdSelected];

                if (!roomInfo.IsOpen)
                {
                    confirmWindow.Show("The room is closed.");
                    return;
                }

                if (roomInfo.PlayerCount >= roomInfo.MaxPlayers)
                {
                    confirmWindow.Show("The room is fulled.");
                    return;
                }

                PhotonNetwork.JoinRoom(roomInfo.Name);
            });

            _openCharacterSelectButton.onClick.AddListener(() =>
            {
                UI_CharacterSelect popup = UI_Manager.instance.Resolve<UI_CharacterSelect>();
                popup.Show();
            });
        }

        private void OnEnable()
        {
            PhotonNetwork.AddCallbackTarget(this);
        }

        private void OnDisable()
        {
            PhotonNetwork.RemoveCallbackTarget(this);
        }

        public void OnJoinedLobby()
        {   
            
            //[ADDED]
            if (SceneManager.GetActiveScene().name != "Lobby") return;
            UI_ConfirmWindow cw = UI_Manager.instance.Resolve<UI_ConfirmWindow>();
            cw.Show("Joined Lobby!");

            /*UI_ConfirmWindow confirmWindow = UI_Manager.instance.Resolve<UI_ConfirmWindow>();
            confirmWindow.Show("Joined lobby.");*/
        }

        public void OnLeftLobby()
        {
            UI_ConfirmWindow confirmWindow = UI_Manager.instance.Resolve<UI_ConfirmWindow>();
            confirmWindow.Show("Left lobby.");
        }

        public void OnLobbyStatisticsUpdate(List<TypedLobbyInfo> lobbyStatistics)
        {
        }

        public void OnRoomListUpdate(List<RoomInfo> roomList)
        {
            RefreshSlots(roomList);
        }

        /// <summary>
        /// Refresh room list slots.
        /// </summary>
        /// <param name="roomList"></param>
        void RefreshSlots(List<RoomInfo> roomList) 
        {
            RoomListSlot slotSelected = _roomListSlots.Find(slot => slot.roomId == _roomIdSelected);
            string selectedRoomName = slotSelected?.name;
            _joinRoom.interactable = false;
            _roomIdSelected = -1;

            // TODO: Pooling slots.
            for (int i = 0; i < _roomListSlots.Count; i++)
            {
                Destroy(_roomListSlots[i].gameObject);
            }

            _roomListSlots.Clear();
            _roomInfosCached.Clear();

            for (int i = 0; i < roomList.Count; i++)
            {
                RoomListSlot slot = Instantiate(_roomListSlot, _roomListSlotContent);
                slot.gameObject.SetActive(true);
                slot.roomId = i;
                slot.roomName = roomList[i].Name;
                slot.roomPlayerCount = roomList[i].PlayerCount;
                slot.roomMaxPlayers = roomList[i].MaxPlayers;
                slot.gameObject.SetActive((roomList[i].RemovedFromList == false) && (roomList[i].PlayerCount > 0));
                _roomListSlots.Add(slot);
                _roomInfosCached.Add(roomList[i]);

                if (roomList[i].Name.Equals(selectedRoomName))
                {
                    _roomIdSelected = i;
                    _joinRoom.interactable = true;
                }
            }
        }

        void OnClick(InputAction.CallbackContext context)
        {
            if (TryGraphicRaycast(Mouse.current.position.ReadValue(), out RoomListSlot slot))
            {
                SelectRoom(slot.roomId);
            }
        }

        void SelectRoom(int roomId)
        {
            RoomInfo roomInfo = _roomInfosCached[roomId];

            if (!roomInfo.IsOpen)
            {
                _joinRoom.interactable = false;
                return;
            }

            if (roomInfo.PlayerCount >= roomInfo.MaxPlayers)
            {
                _joinRoom.interactable = false;
                return;
            }

            _joinRoom.interactable = true;

            if (_roomIdSelected >= 0)
                _roomListSlots[_roomIdSelected].isSelected = false;

            _roomListSlots[roomId].isSelected = true;
            _roomIdSelected = roomId;
        }

        public void OnFriendListUpdate(List<FriendInfo> friendList)
        {
        }

        public void OnCreatedRoom()
        {
        }

        public void OnCreateRoomFailed(short returnCode, string message)
        {
            UI_ConfirmWindow confirmWindow = UI_Manager.instance.Resolve<UI_ConfirmWindow>();
            confirmWindow.Show(message);
        }

        public void OnJoinedRoom()
        {
            PhotonNetwork.LocalPlayer.SetCustomProperties(new ExitGames.Client.Photon.Hashtable
            {
                { PlayerInRoomPropertyKey.IS_READY, false },
            });

            UI_Manager.instance.Resolve<UI_Room>()
                               .Show();
        }

        public void OnJoinRoomFailed(short returnCode, string message)
        {
            UI_ConfirmWindow confirmWindow = UI_Manager.instance.Resolve<UI_ConfirmWindow>();
            confirmWindow.Show(message);
        }

        public void OnJoinRandomFailed(short returnCode, string message)
        {
            UI_ConfirmWindow confirmWindow = UI_Manager.instance.Resolve<UI_ConfirmWindow>();
            confirmWindow.Show(message);
        }

        public void OnLeftRoom()
        {
            Show();
        }
    }
}

// --- UI_Manager.cs ---
using Practices.UGUI_Management.Singletons;
using System;
using System.Collections.Generic;
using UnityEngine;
using Practices.UGUI_Management.Singletons;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Practices.UGUI_Management.UI
{
    public class UI_Manager : Singleton<UI_Manager>
    {
        public UI_Manager()
        {
            _uis = new Dictionary<Type, UI_Base>(EXPECTED_MAX_UI_COUNT_IN_SCENE);
            _popupStack = new List<UI_Popup>(EXPECTED_MAX_POPUP_COUNT_IN_SCENE);
        }

        public IEnumerable<UI_Popup> popups => _popupStack;

        const int EXPECTED_MAX_UI_COUNT_IN_SCENE = 30;
        const int EXPECTED_MAX_POPUP_COUNT_IN_SCENE = 10;

        Dictionary<Type, UI_Base> _uis;
        UI_Screen _screen;
        List<UI_Popup> _popupStack;

        // [CHANGED] 중복 등록 방지 로직
        public void Register(UI_Base ui)
        {
            if (_uis.ContainsKey(ui.GetType()))
            {
                Debug.LogWarning($"UI {ui.GetType()} is already registered. Skipping re-register.");
                return;
            }

            if (_uis.TryAdd(ui.GetType(), ui))
            {
                Debug.Log($"Registered UI {ui.GetType()}");

                if (ui is UI_Popup popup)
                {
                    ui.onShow += () => Push(popup);
                    ui.onHide += () => Pop(popup);
                }
            }
            else
            {
                Debug.LogError($"Failed to register ui {ui.GetType()}. Already exist?");
            }
        }

        public T Resolve<T>() where T : UI_Base
        {
            if (_uis.TryGetValue(typeof(T), out UI_Base result))
            {
                return (T)result;
            }
            else
            {
                string path = $"UI/Canvas - {typeof(T).Name.Substring(3)}";
                UI_Base prefab = Resources.Load<UI_Base>(path);
                if (prefab == null)
                    throw new Exception($"Failed to resolve ui {typeof(T)}. Not exist.");

                return (T)GameObject.Instantiate(prefab);
            }
        }

        public void SetScreen(UI_Screen screen)
        {
            if (_screen != null)
            {
                _screen.inputActionsEnabled = false;
                _screen.Hide();
            }

            _screen = screen;
            _screen.sortingOrder = 0;
            _screen.inputActionsEnabled = true;
        }

        public void Push(UI_Popup popup)
        {
            int popupIndex = _popupStack.FindLastIndex(ui => ui == popup);
            if (popupIndex >= 0)
            {
                _popupStack.RemoveAt(popupIndex);
            }

            int sortingOrder = 1;
            if (_popupStack.Count > 0)
            {
                UI_Popup prevPopup = _popupStack[^1];
                prevPopup.inputActionsEnabled = false;
                sortingOrder = prevPopup.sortingOrder + 1;
            }

            popup.sortingOrder = sortingOrder;
            popup.inputActionsEnabled = true;
            _popupStack.Add(popup);
            Debug.Log($"Pushed {popup.name}");
        }

        public void Pop(UI_Popup popup)
        {
            int popupIndex = _popupStack.FindLastIndex(ui => ui == popup);
            if (popupIndex < 0)
                throw new Exception($"Failed to remove popup. {popup.name}");

            if (popupIndex == _popupStack.Count - 1)
            {
                _popupStack[popupIndex].inputActionsEnabled = false;
                if (popupIndex > 0)
                    _popupStack[popupIndex - 1].inputActionsEnabled = true;
            }

            _popupStack.RemoveAt(popupIndex);
            Debug.Log($"Popped {popup.name}");
        }
    }
}



/*namespace Practices.UGUI_Management.UI
{
    public class UI_Manager : Singleton<UI_Manager>
    {
        public UI_Manager()
        {
            _uis = new Dictionary<Type, UI_Base>(EXPECTED_MAX_UI_COUNT_IN_SCENE); // Reserve 수 : 한 장면에서 최대 사용할 수 있는 UI 갯수
            _popupStack = new List<UI_Popup>(EXPECTED_MAX_POPUP_COUNT_IN_SCENE); // Reserve 수 : 한 장면에서 최대 동시에 띄울 수 있는 Popup 갯수
        }


        public IEnumerable<UI_Popup> popups => _popupStack;

        const int EXPECTED_MAX_UI_COUNT_IN_SCENE = 30;
        const int EXPECTED_MAX_POPUP_COUNT_IN_SCENE = 10;
        Dictionary<Type, UI_Base> _uis; // 현재 장면에서 사용할 수 있는 UI 목록
        UI_Screen _screen; // 현재 장면의 스크린을 차지하는 UI
        List<UI_Popup> _popupStack; // 현재 활성화되어있는 팝업들을 순차적으로 관리하는 스택


        public void Register(UI_Base ui)
        {
            if (_uis.TryAdd(ui.GetType(), ui))
            {
                Debug.Log($"Registered UI {ui.GetType()}");

                if (ui is UI_Popup)
                {
                    ui.onShow += () => Push((UI_Popup)ui);
                    ui.onHide += () => Pop((UI_Popup)ui);
                }
            }
            else
            {
                throw new Exception($"Failed to register ui {ui.GetType()}. already exist.");
            }
        }

        public T Resolve<T>()
            where T : UI_Base
        {
            if (_uis.TryGetValue(typeof(T), out UI_Base result))
            {
                return (T)result;
            }
            else
            {
                string path = $"UI/Canvas - {typeof(T).Name.Substring(3)}";
                UI_Base prefab = Resources.Load<UI_Base>(path);

                if (prefab == null)
                    throw new Exception($"Failed to resolve ui {typeof(T)}. Not exist.");

                return (T)GameObject.Instantiate(prefab);
            }
        }

        public void SetScreen(UI_Screen screen)
        {
            // 이미 활성화된 스크린 UI 가 있으면 끔
            if (_screen != null)
            {
                _screen.inputActionsEnabled = false;
                _screen.Hide();
            }

            _screen = screen;
            _screen.sortingOrder = 0;
            _screen.inputActionsEnabled = true;
        }

        public void Push(UI_Popup popup)
        {
            int popupIndex = _popupStack.FindLastIndex(ui => ui == popup);

            // 이미 이 팝업이 활성화 되어있다면, 제거하고 가장뒤로 보내야함
            if (popupIndex >= 0)
            {
                _popupStack.RemoveAt(popupIndex);
            }

            int sortingOrder = 1;

            if (_popupStack.Count > 0)
            {
                UI_Popup prevPopup = _popupStack[^1];
                prevPopup.inputActionsEnabled = false;
                sortingOrder = prevPopup.sortingOrder + 1;
            }

            popup.sortingOrder = sortingOrder;
            popup.inputActionsEnabled = true;
            _popupStack.Add(popup);
            Debug.Log($"Pushed {popup.name}");
        }

        public void Pop(UI_Popup popup)
        {
            int popupIndex = _popupStack.FindLastIndex(ui => ui == popup);

            if (popupIndex < 0)
                throw new Exception($"Failed to remove popup. {popup.name}");

            // 빼려는게 마지막이었으면 이전꺼를 활성화
            if (popupIndex == _popupStack.Count - 1)
            {
                _popupStack[popupIndex].inputActionsEnabled = false;

                // 이전 팝업이 존재한다면
                if (popupIndex > 0)
                    _popupStack[popupIndex - 1].inputActionsEnabled = true;
            }

            _popupStack.RemoveAt(popupIndex);

            Debug.Log($"Popped {popup.name}");
        }
    }
}*/

// --- UI_Popup.cs ---
using UnityEngine.InputSystem;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;
using Practices.UGUI_Management.Utilities;

namespace Practices.UGUI_Management.UI
{
    public class UI_Popup : UI_Base
    {
        [Resolve] Image _panel;
        private bool _onDragging;


        protected override void Start()
        {
            base.Start();

            playerInputActions.UI.Click.performed += CheckOtherUIClicked;
            playerInputActions.UI.RightClick.performed += CheckOtherUIClicked;
            playerInputActions.UI.Drag.performed += OnDrag;
        }

        void CheckOtherUIClicked(InputAction.CallbackContext context)
        {
            if (context.ReadValueAsButton() == false)
                return;

            Vector2 mousePosition = Mouse.current.position.ReadValue();

            // 일단 이 Canvas 에서 뭔갈 클릭했는지 확인
            if (TryGraphicRaycast(mousePosition, out CanvasRenderer renderer))
            {
                // Nothing todo
            }
            else
            {
                IEnumerable<UI_Popup> popups = manager.popups;

                foreach (UI_Popup popup in popups)
                {
                    if (popup == this)
                        continue;

                    // 유저가 다른 팝업 건드림. 건드린 팝업을 최상단으로 보내줌.
                    if (popup.TryGraphicRaycast(mousePosition, out renderer))
                    {
                        popup.Show();
                        break;
                    }
                }
            }
        }

        void OnDrag(InputAction.CallbackContext context)
        {
            if (TryGraphicRaycast(Mouse.current.position.ReadValue(), out Image result))
            {
                if (result == _panel)
                {
                    StartCoroutine(C_OnDrag(context, Mouse.current.position.ReadValue() - (Vector2)_panel.transform.position));
                }
            }
        }

        IEnumerator C_OnDrag(InputAction.CallbackContext context, Vector2 offset)
        {
            while (context.action.ReadValue<Vector2>().magnitude > 0)
            {
                _panel.transform.position = Mouse.current.position.ReadValue() + offset;
                yield return null;
            }
        }
    }
}

// --- UI_Room.cs ---
// --- UI_Room.cs ---
using TMPro; // TextMeshPro ����
using UnityEngine.UI; // Button
using Practices.UGUI_Management.Utilities;
using Photon.Pun;
using Photon.Realtime;
using ExitGames.Client.Photon;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using Practices.UGUI_Management.UI;

// ...
namespace Practices.PhotonPunClient.UI
{
    public class UI_Room : UI_Screen, IInRoomCallbacks
    {
        [Resolve] private RoomPlayerInfoSlot _roomPlayerInfoSlot;
        [Resolve] private RectTransform _roomPlayerInfoPanel;
        [Resolve] private Button _startGame;
        [Resolve] private Button _gameReady;
        [Resolve] private Button _leftRoom;

        // [ADDED] �Ʒ� �� �ʵ带 Resolve�� ��, 
        // Canvas ������ ������ �̸� & Ÿ���� ��ü�� �־�� �մϴ�.
        [Resolve] private Button _transferMasterButton;      // <-- Button
        [Resolve] private TMP_Dropdown _playerListDropdown;  // <-- TMP_Dropdown

        private Dictionary<int, (Player player, RoomPlayerInfoSlot slot)> _roomPlayerInfoPairs;

        protected override void Awake()
        {
            base.Awake();
            _roomPlayerInfoPairs = new Dictionary<int, (Player, RoomPlayerInfoSlot)>(16);
        }

        private void OnEnable()
        {
            PhotonNetwork.AddCallbackTarget(this);
        }

        private void OnDisable()
        {
            PhotonNetwork.RemoveCallbackTarget(this);
        }

        protected override void Start()
        {
            base.Start();

            // Ȥ�� �Ʒ����� null���� �ݵ�� Ȯ�� (null�̸� ������ ���� ����)
            if (_startGame == null || _transferMasterButton == null ||
                _playerListDropdown == null || _roomPlayerInfoSlot == null)
            {
                Debug.LogError("[UI_Room] Some references are missing!");
                return;
            }

            // ���� �ڵ�� ����
            _roomPlayerInfoSlot.gameObject.SetActive(false);

            _startGame.onClick.AddListener(OnClickStartGame);
            _gameReady.onClick.AddListener(OnClickReady);
            _leftRoom.onClick.AddListener(OnClickLeaveRoom);
            _transferMasterButton.onClick.AddListener(OnClickTransferMaster);
        }

        // [ADDED] StartGame ��ư Ŭ��
        private void OnClickStartGame()
        {
            // ��: �ּ� 2�� �̻��� ����
            if (PhotonNetwork.LocalPlayer.IsMasterClient &&
                PhotonNetwork.CurrentRoom.PlayerCount >= 2)
            {
                // �� �ε�
                UnityEngine.SceneManagement.SceneManager.LoadScene("GamePlay");
            }
            else
            {
                Debug.LogWarning("[UI_Room] Not enough players or not master client");
            }
        }

        // [ADDED] Ready ��ư Ŭ��
        private void OnClickReady()
        {
            var player = PhotonNetwork.LocalPlayer;
            bool isReady = _roomPlayerInfoPairs[player.ActorNumber].slot.isReady;

            player.SetCustomProperties(new Hashtable
            {
                { PlayerInRoomPropertyKey.IS_READY, !isReady }
            });
        }

        // [ADDED] �� ������
        private void OnClickLeaveRoom()
        {
            // Photon �濡�� ������ �� OnLeftRoom �ݹ鿡�� �κ� ���� �ε�
            PhotonNetwork.LeaveRoom();
        }

        // [ADDED] ���� ���� �ѱ��
        private void OnClickTransferMaster()
        {
            if (!PhotonNetwork.LocalPlayer.IsMasterClient) return;

            // Dropdown�� value�� Ÿ�� ����
            int idx = _playerListDropdown.value;
            var players = _roomPlayerInfoPairs.Values.Select(v => v.player).ToList();
            if (idx >= 0 && idx < players.Count)
            {
                Player target = players[idx];
                PhotonNetwork.SetMasterClient(target);
            }
        }

        public override void Show()
        {
            base.Show();

            // ������ �ִ� ���Ե� ����
            foreach (int actorNumber in _roomPlayerInfoPairs.Keys.ToList())
            {
                Destroy(_roomPlayerInfoPairs[actorNumber].slot.gameObject);
            }
            _roomPlayerInfoPairs.Clear();

            // ���� ���� ����
            foreach (Player player in PhotonNetwork.PlayerList)
            {
                RoomPlayerInfoSlot slot = Instantiate(_roomPlayerInfoSlot, _roomPlayerInfoPanel);
                slot.gameObject.SetActive(true);
                slot.actorNumber = player.ActorNumber;
                slot.isMasterClient = player.IsMasterClient;

                // ������ IS_READY�� ������ �ݿ�
                if (player.CustomProperties.TryGetValue(PlayerInRoomPropertyKey.IS_READY, out object val))
                {
                    slot.isReady = (bool)val;
                }
                else
                {
                    slot.isReady = false;
                }

                _roomPlayerInfoPairs.Add(player.ActorNumber, (player, slot));
            }

            UpdatePlayerListDropdown();
            TogglePlayerButtons(PhotonNetwork.LocalPlayer);
        }

       // [ADDED]
        private void TogglePlayerButtons(Player localPlayer)
        {
            // ���常 StartGame, TransferMasterButton ���̱�
            bool isMaster = localPlayer.IsMasterClient;
            _startGame.gameObject.SetActive(isMaster);
            _transferMasterButton.gameObject.SetActive(isMaster);

            // ������ �ƴϸ� Ready ��ư ���̱�
            _gameReady.gameObject.SetActive(!isMaster);

            // [CHANGED] "StartGame" ��ư�� �ο��� 2�� �̻��� ����
            // �Ʒ�ó�� ���� üũ
            _startGame.interactable = (PhotonNetwork.CurrentRoom.PlayerCount >= 2);
        }

       // [ADDED]
        private void UpdatePlayerListDropdown()
        {
            if (_playerListDropdown == null)
            {
                Debug.LogError("[UI_Room] _playerListDropdown is null!");
                return;
            }

            _playerListDropdown.ClearOptions();
            var names = _roomPlayerInfoPairs.Values.Select(v => v.player.NickName).ToList();
            _playerListDropdown.AddOptions(names);
            _playerListDropdown.value = 0; // �⺻���� ù ��° ����
        }

        // ------------------------- IInRoomCallbacks -------------------------
        public void OnMasterClientSwitched(Player newMasterClient)
        {
            // ���� ������ false
            var oldMasterPair = _roomPlayerInfoPairs.FirstOrDefault(pair => pair.Value.slot.isMasterClient);
            if (!oldMasterPair.Equals(default(KeyValuePair<int, (Player, RoomPlayerInfoSlot)>)))
            {
                oldMasterPair.Value.slot.isMasterClient = false;
            }
            // �� ������ true
            if (_roomPlayerInfoPairs.TryGetValue(newMasterClient.ActorNumber, out var newMasterPair))
            {
                newMasterPair.slot.isMasterClient = true;
            }

            if (newMasterClient.ActorNumber == PhotonNetwork.LocalPlayer.ActorNumber)
            {
                // UI ��ư ���� ������Ʈ
                TogglePlayerButtons(newMasterClient);
            }
        }

        public void OnPlayerEnteredRoom(Player newPlayer)
        {
            RoomPlayerInfoSlot slot = Instantiate(_roomPlayerInfoSlot, _roomPlayerInfoPanel);
            slot.gameObject.SetActive(true);
            slot.actorNumber = newPlayer.ActorNumber;
            slot.isReady = false;
            _roomPlayerInfoPairs.Add(newPlayer.ActorNumber, (newPlayer, slot));

            UpdatePlayerListDropdown();
            TogglePlayerButtons(PhotonNetwork.LocalPlayer);
        }

        public void OnPlayerLeftRoom(Player otherPlayer)
        {
            if (_roomPlayerInfoPairs.TryGetValue(otherPlayer.ActorNumber, out var pair))
            {
                Destroy(pair.slot.gameObject);
                _roomPlayerInfoPairs.Remove(otherPlayer.ActorNumber);
            }
            UpdatePlayerListDropdown();
            TogglePlayerButtons(PhotonNetwork.LocalPlayer);
        }

        public void OnPlayerPropertiesUpdate(Player targetPlayer, Hashtable changedProps)
        {
            if (_roomPlayerInfoPairs.TryGetValue(targetPlayer.ActorNumber, out var pair))
            {
                if (changedProps.TryGetValue(PlayerInRoomPropertyKey.IS_READY, out object obj))
                {
                    pair.slot.isReady = (bool)obj;
                }
            }
        }

        public void OnRoomPropertiesUpdate(Hashtable propertiesThatChanged)
        {
            // �ʿ��ϸ� ����
        }
    }
}


// --- UI_Screen.cs ---
namespace Practices.UGUI_Management.UI
{
    public class UI_Screen : UI_Base
    {
        public override void Show()
        {
            base.Show();

            manager.SetScreen(this);
        }
    }
}

// --- FinishLineTrigger.cs ---
// [ADDED FILE] FinishLineTrigger.cs
// 결승점 Collider(isTrigger) 오브젝트에 부착
using Photon.Pun;
using Photon.Realtime;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class FinishLineTrigger : MonoBehaviourPun
{
    // 마스터에서 도착 순서 기록
    private List<(int actorNumber, double finishTime)> _finishList = new List<(int, double)>();
    private bool _finishAnnounced = false;

    private void OnTriggerEnter(Collider other)
    {
        if (!PhotonNetwork.IsMasterClient) return;

        if (other.CompareTag("Player"))
        {
            PhotonView pv = other.GetComponent<PhotonView>();
            if (pv != null)
            {
                int actorNumber = pv.OwnerActorNr;
                bool alreadyFinished = _finishList.Any(x => x.actorNumber == actorNumber);

                if (!alreadyFinished)
                {
                    double t = PhotonNetwork.Time;
                    _finishList.Add((actorNumber, t));
                    photonView.RPC(nameof(RpcOnPlayerFinished), RpcTarget.All, actorNumber, t);

                    // 예: 모든 인원이 도착했는지 체크 (혹은 3명만 순위매긴다든지)
                    if (_finishList.Count >= PhotonNetwork.CurrentRoom.PlayerCount)
                    {
                        // 전원 도착
                        AnnounceFinalResult();
                    }
                }
            }
        }
    }

    [PunRPC]
    private void RpcOnPlayerFinished(int actorNumber, double finishTime)
    {
        Debug.Log($"Player {actorNumber} finished at time={finishTime}");
        // 필요시 UI 표기
    }

    // 마스터 전용 결과 발표
    void AnnounceFinalResult()
    {
        if (_finishAnnounced) return;
        _finishAnnounced = true;

        // 도착시간 빠른 순으로 정렬
        var ranking = _finishList.OrderBy(x => x.finishTime).ToList();
        // 1등 ~
        for (int i = 0; i < ranking.Count; i++)
        {
            Debug.Log($"Rank {i + 1}: Actor={ranking[i].actorNumber}, time={ranking[i].finishTime}");
        }

        // TODO: PhotonNetwork.RPC로 모든 클라이언트에게 전달하거나,
        // GamePlayManager와 연동하여 종료 처리 등

        StartCoroutine(CoFinishInSeconds(5f)); // 5초 후 종료/로비
    }

    IEnumerator CoFinishInSeconds(float sec)
    {
        yield return new WaitForSeconds(sec);
        PhotonNetwork.LeaveRoom();
        UnityEngine.SceneManagement.SceneManager.LoadScene("Lobby");
    }
}

// --- GamePlayManager.cs ---
// [ADDED FILE] GamePlayManager.cs
// 게임 씬에서 인원 체크, 플레이어 퇴장 처리, 게임 종료/승리 로직 등 담당
using Photon.Pun;
using Photon.Realtime;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class GamePlayManager : MonoBehaviourPunCallbacks
{
    private bool _gameFinished = false;

    // [ADDED] 게임 시작 시 인원 기록 (필요하다면)
    private int _playerCountAtStart;

    void Start()
    {
        // 현재 인원 체크
        _playerCountAtStart = PhotonNetwork.CurrentRoom.PlayerCount;
        Debug.Log($"[GamePlayManager] Start with {_playerCountAtStart} players.");
    }

    public override void OnPlayerLeftRoom(Player otherPlayer)
    {
        base.OnPlayerLeftRoom(otherPlayer);

        if (_gameFinished) return;

        int currentCount = PhotonNetwork.CurrentRoom.PlayerCount;
        Debug.Log($"[GamePlayManager] Player Left => Current count = {currentCount}");

        // 남은 인원이 1명 이하라면 즉시 게임 종료
        if (currentCount <= 1)
        {
            // 남아있는 플레이어 = 우승
            foreach (var kvp in PhotonNetwork.CurrentRoom.Players)
            {
                Player p = kvp.Value;
                if (p != otherPlayer)
                {
                    Debug.Log($"[GamePlayManager] Player {p.ActorNumber} is the winner (Last man).");
                    ShowResultAndFinish(p);
                    return;
                }
            }
        }
    }

    void ShowResultAndFinish(Player winner)
    {
        _gameFinished = true;
        Debug.Log($"[GamePlayManager] Game Finished! Winner: {winner.NickName}");
        StartCoroutine(CoFinishGame());
    }

    IEnumerator CoFinishGame()
    {
        // 3초 후 로비로
        yield return new WaitForSeconds(3f);
        PhotonNetwork.LeaveRoom();
        SceneManager.LoadScene("Lobby");
    }
}

// --- GamePlayWorkflow.cs ---
// [CHANGED FILE] GamePlayWorkflow.cs
using Photon.Pun;
using Photon.Realtime;
using System.Collections;
using UnityEngine;

namespace Practices.PhotonPunClient
{
    public class GamePlayWorkflow : MonoBehaviour
    {
        WaitForSeconds _waitFor1Seconds = new WaitForSeconds(1);

        private void Start()
        {
            StartCoroutine(C_Workflow());
        }

        IEnumerator C_Workflow()
        {
            SpawnPlayerCharacter();
            yield return StartCoroutine(C_WaitUntilAllPlayerCharactersAreSpawned());
            // TODO: Player input enable or Countdown
        }

        // [CHANGED] SpawnPlayerCharacter: ���õ� ĳ����(SelectedCharacter) ���
        void SpawnPlayerCharacter()
        {
            // Ŀ���� ������Ƽ���� �������ų�, �⺻ "Warrior"
            string charName = "Warrior";
            if (PhotonNetwork.LocalPlayer.CustomProperties.TryGetValue("SelectedCharacter", out object obj))
            {
                charName = (string)obj;
            }

            Vector2 xz = Random.insideUnitCircle * 5f;
            Vector3 randomPosition = new Vector3(xz.x, 0f, xz.y);

            // [CHANGED] Characters/{charName} �������� Instantiate
            PhotonNetwork.Instantiate($"Characters/{charName}", randomPosition, Quaternion.identity);
        }

        IEnumerator C_WaitUntilAllPlayerCharactersAreSpawned()
        {
            while (true)
            {
                bool allReady = true;

                foreach (Player player in PhotonNetwork.PlayerList)
                {
                    if (player.CustomProperties.TryGetValue(PlayerInGamePlayPropertyKey.IS_CHARACTER_SPAWNED, out object isSpawnedObj))
                    {
                        if (!(bool)isSpawnedObj)
                        {
                            allReady = false;
                            break;
                        }
                    }
                    else
                    {
                        allReady = false;
                        break;
                    }
                }

                if (allReady) break;

                yield return _waitFor1Seconds;
            }
        }
    }
}


// --- LobbySceneWorkflow.cs ---
using Photon.Pun;
using Practices.PhotonPunClient.UI;
using Practices.UGUI_Management.UI;
using System.Collections;
using UnityEngine;

namespace Practices.GameClient.Workflows
{
    public class LobbySceneWorkflow : MonoBehaviour
    {
        private void Start()
        {
            StartCoroutine(C_Workflow());
        }

        IEnumerator C_Workflow()
        {
            //UI_Manager uiManager = UI_Manager.instance;

            // Photon server 에 접속완료 될때까지 기다림.
            yield return new WaitUntil(() => PhotonNetwork.IsConnected);
            // 로비 UI 다시 생성 or Resolve
            UI_Manager.instance.Resolve<UI_Lobby>().Show();

            //uiManager.Resolve<UI_Lobby>()
            //       .Show();
        }
    }
}

